---
title: "Tutorial: Running the pipeline"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Tutorial: Running the pipeline}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
# Load libraries
library(staRgate)
# Do we need to load the below if they are dependencies of staRgate?
library(openCyto)
library(tidyverse)
library(flowCore)
library(glue)
library(flowAI)
library(flowWorkspace)
library(readxl)
library(janitor)

# Set up dynamic variables 
## Below are examples
# ## String: sample name
# pt_samp_nm = "flow_sample_1"
# 
# ## File path to the FCS file
# path_fcs = "./flow_sample_1.fcs"
# 
# ## File path to the compensation matrix csv file
# ## Expect format to match flowJo exported version
# path_comp_mat = "./flow_sample_1_comp_mat.csv"
# 
# ## File path for outputs/saving
# path_out = "./output"
# 
# ## File path to gating template
# gtFile = "./flow_tcell_gating_template.csv"
# 
# ## File path to biexp parameters
# ## Expects 4 columns: full_name, ext_neg_dec, width_basis, positive_dec
# ## full name should contain the channel/dye name
# #3 remaining cols fill in with desired parameter values
# path_biexp_params = "./flow_biexp_param.csv"
# ## File path to positive peak thresholds
# path_pos_peak_thresholds = "./pos_peak_thresholds.csv"

# After adding inst/extdata
pt_samp_nm = "flow_sample_1"

## File path to the FCS file
path_fcs = system.file("extdata", "example_fcs.fcs", package = "staRgate", mustWork = TRUE)

## File path to the compensation matrix csv file
## Expect format to match flowJo exported version
path_comp_mat = system.file("extdata", "comp_mat_example_fcs.csv", package = "staRgate", mustWork = TRUE)

## File path for outputs/saving
# Maybe not the best sol, but create a temp dir?
path_out = tempdir()
# Print the path_out for user to see
path_out

## File path Gating template
gtFile = system.file("extdata", "gating_template_x50_tcell.csv", package = "staRgate", mustWork = TRUE)

## File path to biexp parameters
## Expects 4 columns: full_name, ext_neg_dec, width_basis, positive_dec
## full name should contain the channel/dye name
#3 remaining cols fill in with desired parameter values
path_biexp_params = system.file("extdata", "biexp_transf_parameters_x50.csv", package = "staRgate", mustWork = TRUE)

## File path to positive peak thresholds
path_pos_peak_thresholds = system.file("extdata", "pos_peak_thresholds.csv", package = "staRgate", mustWork = TRUE)

```

```{r}
# Some preferred ggplot settings. 
# Not required/relevant for gating

plot_font_size = 13

theme_set(theme_bw() +
            theme(text = element_text(size = plot_font_size),
                  axis.text = element_text(color = "black"),
                  legend.position = 'bottom') )
```


# Import FCS, preprocessing (compensation and transformation) and pre-gating

```{r}
# 2023-06-19 Test if we can pass in a gating set and return a gs
# First check that we can return a gs? Yes it worked
  ### Read in file
  dtTemplate = data.table::fread(gtFile)
  
  ### Load
  gt_tcell = openCyto::gatingTemplate(gtFile)
  
  cs  <- flowWorkspace::load_cytoset_from_fcs(path_fcs)
  
  ## Create a GatingSet of 1 sample
  gs = flowWorkspace::GatingSet(cs)
  
  # Check no comp applied
  flowWorkspace::gh_get_compensations(gs)
  
  # Apply comp 
  gs = get_comp_gs(gs, path_comp_mat = path_comp_mat)
  
  # Can check that the comp was applied
  flowWorkspace::gh_get_compensations(gs)

  # Check no transformation before
  gh_get_transformations(gs)
  
  # grab the ver negative values to check what they correspond to 
  dat_pre_transform = 
    gs %>% 
    flowWorkspace::gh_pop_get_data() %>% 
    flowCore::exprs()
  
  
  # Apply biexp trans
  gs = get_biexpTransform_gs(gs, path_biexp_params = path_biexp_params)

  # Check transformation applied
  gh_get_transformations(gs)
  
  dat_post_transform = 
    gs %>% 
    flowWorkspace::gh_pop_get_data() %>% 
    flowCore::exprs()
    
  summary(dat_pre_transform)
    
  # Pre-gating up to CD3+ with {openCyto}
  ## Set seed using today's date 
  set.seed(glue::glue({format(Sys.Date(), format = "%Y%m%d")}))
  
  # openCyto::gt_gating(gt_tcell, gs_qc)
  openCyto::gt_gating(gt_tcell, gs)
  
  ## Check autoplot
  ggcyto::autoplot(gs[[1]])
  
  # To prevent breakage down the road
  gs_qc = gs
  rm(gs)
  
  # Extract intensity matrix from GatingSet object
  ## Grab marker names from GatingSet for labeling col names in intensity matrix
  marker_chnl_names = 
    flowWorkspace::gh_pop_get_data(gs_qc) %>% 
    flowWorkspace::markernames() %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column() %>% 
    dplyr::rename(chnl = rowname, 
           marker_full = ".") %>% 
    # clean up the names 
    dplyr::mutate(
      marker_full = janitor::make_clean_names(marker_full, replace = c("-" = "", "_" = "", " " = "")) %>% toupper()
    ) %>% 
    # Reorder the marker channel names to start with CD3, CD4, CD8 then the rest
    dplyr::arrange(match(marker_full, c("CD3", "CD4", "CD8"))) %>% 
    # Clean up
    dplyr::mutate(marker_full = ifelse(marker_full == "FOX_P3", "FOXP3", marker_full))
  
  # For filtering out neg values below for any intensity cols
  neg_intensity_thres = -2000
  
  markers_to_gate = 
    marker_chnl_names$marker_full %>%
    .[!(. %in% c("CD3", "CD4", 'CD8', "LD", "CD1419"))]
    
  
  ## Grab the intensity matrix from GatingSet
  ## the gh_pop_get_indices grabs the 0/1 for whether gated as CD3
  intensity_dat = 
    gs_qc %>% 
    flowWorkspace::gh_pop_get_indices(y = "cd3") %>% 
    cbind(gs_qc %>%  
            flowWorkspace::gh_pop_get_data() %>% 
            flowCore::exprs(),
          "cd3_pos" = .) %>% 
  # add on the cd4 and cd8 0/1s
    cbind(., 
          "cd4_pos" = gh_pop_get_indices(gs_qc, y = "cd4+")) %>% 
    cbind(., 
          "cd8_pos" = gh_pop_get_indices(gs_qc, y = "cd8+")) %>% 
    tibble::as_tibble() %>%
    # Rename for plotting
    dplyr::rename(stats::setNames(marker_chnl_names$chnl, as.character(marker_chnl_names$marker_full))) %>%
    dplyr::mutate(
      cd4_pos_cd8_pos = case_when(
        cd3_pos == 1 & cd4_pos == 1 & cd8_pos == 1 ~ "cd4_pos_cd8_pos",
        cd3_pos == 1 & cd4_pos == 1 & cd8_pos == 0 ~ "cd4_pos_cd8_neg",
        cd3_pos == 1 & cd4_pos == 0 & cd8_pos == 1 ~ "cd4_neg_cd8_pos",
        cd3_pos == 1 & cd4_pos == 0 & cd8_pos == 0 ~ "cd4_neg_cd8_neg"
      ),
      # Add a subsetting col to do pooled
      pooled_col = 
        dplyr::case_when(cd3_pos == 1 ~ "cd3_pos")
    ) 
  
  ## Preview of intensity matrix
  head(intensity_dat)
  
```


# Example of density gating


+ Current strategy is based on all CD3+

```{r}
# Density gating parameters
peak_r = 10
bin_i = 50

# Read in positive peak thresholds
pos_thres = read.csv(path_pos_peak_thresholds)

# Plot lag3
intensity_dat %>% 
  dplyr::filter(cd3_pos == 1) %>% 
  # additional step to remove large intensity values only when density gating. 
  # Still kept in the data
  dplyr::filter(!(if_any(all_of(markers_to_gate), ~.x < neg_intensity_thres)))%>% 
  ggplot() + 
  geom_density(aes(LAG3)) +
  labs(subtitle = "Distribution of LAG3 intensity on all CD3+")

example_gate = 
  intensity_dat %>% 
  dplyr::filter(cd3_pos == 1) %>% 
  # additional step to remove large intensity values only when density gating. 
  # Still kept in the data
  dplyr::filter(!(if_any(all_of(markers_to_gate), ~.x < neg_intensity_thres))) %>% 
  get_density_gates(intens_dat = . , 
                    marker = "LAG3",
                    subset_col = "pooled_col",
                    bin_n = bin_i,
                    peak_detect_ratio = peak_r,
                    pos_peak_threshold = pos_thres %>% 
                      dplyr::filter(marker == "LAG3") %>% 
                      dplyr::pull(pos_peak_threshold) %>% 
                      unname()) %>% 
  # 2023-08-28 ad hoc add rows per cd4/cd8 subsets
  # TODO: integrate more nicely
  tibble::add_row() %>% 
  tibble::add_row() %>% 
  tibble::add_row() %>% 
  dplyr::mutate(cd4_pos_cd8_pos = c("cd4_neg_cd8_neg", "cd4_pos_cd8_neg", "cd4_neg_cd8_pos", "cd4_pos_cd8_pos")) %>% 
  tidyr::fill(pooled_col, c("LAG3"), .direction = "down")
  

# View results
example_gate

# try get indicator col
example_intensity_gated_lag3 = 
  get_gated_dat(intensity_dat %>% 
                  dplyr::filter(cd3_pos == 1),
                subset_col = "cd4_pos_cd8_pos", 
                cutoffs = example_gate)


# Plot the gate for visual
intensity_dat %>% 
  dplyr::filter(cd3_pos == 1) %>% 
  # additional step to remove large intensity values only when density gating. 
  # Still kept in the data
  dplyr::filter(!(if_any(all_of(markers_to_gate), ~.x < neg_intensity_thres)))%>% 
  ggplot() + 
  geom_density(aes(LAG3)) +
  geom_vline(data = example_gate, 
             aes(xintercept = LAG3),
             color = "blue", 
             linetype = "dashed") + 
  labs(subtitle = "Distribution of LAG3 intensity on all CD3+. Gate identifed by {staRgate} in blue.")

# If by CD4/CD8, 

intensity_dat %>% 
  dplyr::filter(cd3_pos == 1) %>% 
  # additional step to remove large intensity values only when density gating. 
  # Still kept in the data
  dplyr::filter(!(if_any(all_of(markers_to_gate), ~.x < neg_intensity_thres)))%>% 
  ggplot() + 
  geom_density(aes(LAG3)) +
  geom_vline(data = example_gate, 
             aes(xintercept = LAG3),
             color = "blue", 
             linetype = "dashed") + 
  labs(subtitle = "Distribution of LAG3 intensity on all CD3+. Gate identifed by {staRgate} in blue.") + 
  facet_wrap(~cd4_pos_cd8_pos)

```

```{r}
# TODO: add a purrr::map() example of density gating applied to all markers for a more complete example
```

