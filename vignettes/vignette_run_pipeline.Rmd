---
title: "Tutorial: Running the pipeline"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Tutorial: Running the pipeline}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
# Load libraries
library(staRgate)
# Do we need to load the below if they are dependencies of staRgate?
library(openCyto)
library(tidyverse)
library(flowCore)
library(glue)
library(flowAI)
library(flowWorkspace)
library(readxl)
library(janitor)

# Set up dynamic variables 
## Below are examples
# ## String: sample name
# pt_samp_nm = "flow_sample_1"
# 
# ## File path to the FCS file
# path_fcs = "./flow_sample_1.fcs"
# 
# ## File path to the compensation matrix csv file
# ## Expect format to match flowJo exported version
# path_comp_mat = "./flow_sample_1_comp_mat.csv"
# 
# ## File path for outputs/saving
# path_out = "./output"
# 
# ## File path to gating template
# gtFile = "./flow_tcell_gating_template.csv"
# 
# ## File path to biexp parameters
# ## Expects 4 columns: full_name, ext_neg_dec, width_basis, positive_dec
# ## full name should contain the channel/dye name
# #3 remaining cols fill in with desired parameter values
# path_biexp_params = "./flow_biexp_param.xlsx"

# ACtual file paths
pt_samp_nm = "Specimen_tube_001.fcs"

## File path to the FCS file
path_fcs = "H:/Biostatistics/PICI/data/BMS_rela_nivo_CA2024020/CA224020_Rela Nivo_MSK FCS Files/Specimen_tube_001.fcs"

## File path to the compensation matrix csv file
## Expect format to match flowJo exported version
path_comp_mat = "H:/Biostatistics/PICI/data/BMS_rela_nivo_CA2024020/BMS Rela Nivo_Compensations/BMS Rela Nivo_Compensations/AcqDef_20220602.csv"

# # The 17-162 comp mats are slightly diff convention , test itworks as well
# path_comp_mat = "H:/Biostatistics/Ronglai-Jasme/flow/data/FCS_from_Matt/17-162 Astrolabe_MSKCC/17-162 FCS Files/comp_mat/17-162-03.csv"
  

## File path for outputs/saving
# TODO: don't save for now
# Unsure where would one save this for a vignette?
# path_out = "./output"

## File path to gating template
## TODO: add gt and params to data folder
gtFile = "G:/!GDriveMigratedData/My Documents/GitHub/Projects/PICI/flow_cytometry/flow_cytometry/automated_gating/gating_templates/x50_tcell_up_to_cd4_cd8_rela.csv"

## File path to biexp parameters
## Expects 4 columns: full_name, ext_neg_dec, width_basis, positive_dec
## full name should contain the channel/dye name
#3 remaining cols fill in with desired parameter values
# path_biexp_params = "G:/!GDriveMigratedData/My Documents/GitHub/Projects/PICI/flow_cytometry/flow_cytometry/automated_gating/biexp_transformation_parameters/biexp_transf_parameters_X50_bms_rela.xlsx"

path_biexp_params = 
  # "G:/!GDriveMigratedData/My Documents/GitHub/Projects/PICI/flow_cytometry/flow_cytometry/automated_gating/biexp_transformation_parameters/biexp_transf_parameters_X50_bms.csv"
  "H:/Biostatistics/Profiles/LeeJ22/flow_cytometry/biexp_transformation_parameters/biexp_transf_parameters_X50_bms_rela.csv"
```

```{r}
# 2023-06-19 Test if we can pass in a gating set and return a gs
# First check that we can return a gs? Yes it worked
  ### Read in file
  dtTemplate = data.table::fread(gtFile)
  
  ### Load
  gt_tcell = openCyto::gatingTemplate(gtFile)
  
  cs  <- flowWorkspace::load_cytoset_from_fcs(path_fcs)
  
  ## Create a GatingSet of 1 sample
  gs = flowWorkspace::GatingSet(cs)
  
  # Check no comp applied
  flowWorkspace::gh_get_compensations(gs)
  
  # Apply comp 
  gs = get_comp_gs(gs, path_comp_mat = path_comp_mat)
  
  # Can check that the comp was applied
  flowWorkspace::gh_get_compensations(gs)

  # Check no transformation before
  gh_get_transformations(gs)
  
  # grab the ver negative values to check what they correspond to 
  dat_pre_transform = 
    gs %>% 
    flowWorkspace::gh_pop_get_data() %>% 
    flowCore::exprs()
  
  
  # Apply biexp trans
  gs = get_biexpTransform_gs(gs, path_biexp_params = path_biexp_params)

  # Check transformation applied
  gh_get_transformations(gs)
  
  dat_post_transform = 
    gs %>% 
    flowWorkspace::gh_pop_get_data() %>% 
    flowCore::exprs()
    
  summary(dat_pre_transform)
  
  # Merge the pre and post transformed cols for APC_A
  aux_var = "APC-A"
  
  test = 
    tibble(
    pre = dat_pre_transform[, aux_var], 
    post = dat_post_transform[, aux_var] 
  )
  
  test %>% 
    dplyr::filter(post <= -1000) %>% 
    arrange(-post) %>%
    head(n = 10)
  
  test %>% 
    dplyr::filter(post >= 1600) %>% 
    arrange(post) %>%
    head(n = 10)
  # For APC-A , 
  # -2000 corresponds to approx -5800 on original scale
  # -1000 ~ >3300
  # For ref, the flowJo plots usually only go up to -10^3 or -1000
  
```


```{r}
# Load gating template
## Modified the T cell gating template from {openCyto}

### Read in file
dtTemplate = data.table::fread(gtFile)

### Load
gt_tcell = openCyto::gatingTemplate(gtFile)

# Optional to check the template
# gt_tcell
# plot(gt_tcell)


# Import FCS, Build GatingSet
## read in the fcs files
cs  <- flowWorkspace::load_cytoset_from_fcs(glue::glue("{path_fcs}"))

## change "Viability" or "L/D" to = "L_D" for consistency
{if(any(c("Viability", "L/D", "LD") %in% flowWorkspace::markernames(cs))){
  aux_log = flowWorkspace::markernames(cs) == "Viability" | flowWorkspace::markernames(cs) == "L/D" | flowWorkspace::markernames(cs) == "LD"
  
  markernames(cs) = replace(markernames(cs), aux_log, "L_D")}
}

## Create a GatingSet of 1 sample
gs = flowWorkspace::GatingSet(cs)

# Compensation
## Import comp. mat. csv exported from flowJo
comp.mat = read.csv(path_comp_mat,
                    header = TRUE, 
                    skip = 0) 

## Optional to check comp mat
## comp.mat %>%
##   head

## Can remove the X col because that's the row names 
comp.mat = 
  comp.mat %>% 
  tibble::column_to_rownames(var = "X")

## clean up the col names of the comp.mat 
marker_chnl_names = 
  tibble::tibble(colnms = colnames(comp.mat)) %>% 
  tidyr::separate(colnms, c("chnl", "marker"), sep = "\\.\\.\\.\\.", remove = FALSE)

## further clean up some of the col nanmes to match channel names in `gs`
comp.mat = 
  comp.mat %>% 
  dplyr::rename(stats::setNames(marker_chnl_names$colnms, gsub("\\.", "-", marker_chnl_names$chnl))) %>% 
  {if("PE.Cy5.5.A" %in% marker_chnl_names$chnl) dplyr::rename(., "PE-Cy5.5-A" = "PE-Cy5-5-A")
    else dplyr::rename(.)} %>% 
  {if("Alexa.Fluor.700.A" %in% marker_chnl_names$chnl) dplyr::rename(., "Alexa Fluor 700-A" = "Alexa-Fluor-700-A")
    else dplyr::rename(.)} %>% 
  {if("Horizon.V450.A" %in% marker_chnl_names$chnl) dplyr::rename(., "Horizon V450-A" = "Horizon-V450-A")
    else dplyr::rename(.)} %>% 
  {if("Pacific.Orange.A" %in% marker_chnl_names$chnl) dplyr::rename(., "Pacific Orange-A" = "Pacific-Orange-A")
    else dplyr::rename(.)} %>% 
  {if("Qdot.605.A" %in% marker_chnl_names$chnl) dplyr::rename(., "Qdot 605-A" = "Qdot-605-A")
    else dplyr::rename(.)} %>% 
  {if("Qdot.655.A" %in% marker_chnl_names$chnl) dplyr::rename(., "Qdot 655-A" = "Qdot-655-A")
    else dplyr::rename(.)}


# ## Check col names are equal
# colnames(comp.mat) == (colnames(cs) %>% .[!(grepl("FSC|SSC|Time", .))])

## Create the `compensation` object with `flowCore::compensation()`
comp = flowCore::compensation(comp.mat)

## Apply compensation to the `GatingSet` with `flowCore::compensate()`
### Must have the colnames in `comp.mat` match the channel names in the `cytoset` 
gs = flowCore::compensate(gs, comp)

# Transformation
## Read in the table of parameters
tbl_biexp_params = 
  readxl::read_xlsx(path_biexp_params) %>% 
  janitor::clean_names(case = "all_caps") 

## loop through all the channels and create a biexpTrans object per channel
biexpTrans = 
  purrr::pmap(
    list(p = tbl_biexp_params$POSITIVE_DEC,
         n = tbl_biexp_params$EXT_NEG_DEC, 
         wb = tbl_biexp_params$WIDTH_BASIS),
    function(p, n, wb, ...){
      flowWorkspace::flowjo_biexp_trans(pos = p,
                                        neg = n,
                                        widthBasis = wb)
      
    }
  )


## Give names
names(biexpTrans) = tbl_biexp_params$FULL_NAME


## Optional - Checks that all channels have a matching biexpTrans object
# lapply(biexpTrans, 
#        FUN = function(x){x[["transform"]] %>% attr(., "parameters")}) %>% 
#   dplyr::bind_rows(.id = "channel") 
# 
# ## Do channel names match the names of biexpTrans?
# all(names(biexpTrans) %in% parameters(comp))
# all(names(biexpTrans) %in% names(markernames(gs)))

## Create transformerList in order to apply to gs
trans = transformerList(names(biexpTrans), biexpTrans)

## Optional - Check the values before transformation
# gs %>% 
#   gh_pop_get_data() %>% 
#   summary()

## Apply to gs
gs = transform(gs, trans)

## optional - Check values after transformation
# gs %>% 
#   gh_pop_get_data() %>% 
#   summary()

# Quality/time gate with {flowAI}
## function expect flowSet/flowFrame as input rather than a GatingSet
## use flowWorkspace::gh_pop_get_data() to grab the flowSet
## User can define where to save outputs for report from {flowai]}


# TODO Add an arg to specify whether to run flowAI
# ## If dir doesn't exist, create one
# if(!dir.exists(here::here(glue("{path_out}/flowAI_results")))){
#   dir.create(here::here(glue("{path_out}/flowAI_results")))
# }
# 
# qc = flowAI::flow_auto_qc(flowWorkspace::gh_pop_get_data(gs),
#                           folder_results = here::here(glue("{path_out}/flowAI_results")))
# 
# ## Convert to a flowSet in order to convert back to GatingSet
# qc_fs = 
#   qc %>% 
#   # First convert to a flowSet
#   flowCore::flowSet()
# 
# ## Rename the sample 
# flowCore::sampleNames(qc_fs) = pt_samp_nm
# 
# ## convert the flowFrame obj returned in qc_fs to a GatingSet to pass to openCyto
# gs_qc =  
#   qc_fs %>% 
#   flowWorkspace::GatingSet()
# 
# ## Remote the qc_fs object as it's no longer needed
# rm(qc_fs)

# Pre-gating up to CD3+ with {openCyto}
## Set seed using today's date 
set.seed(glue::glue({format(Sys.Date(), format = "%Y%m%d")}))

# openCyto::gt_gating(gt_tcell, gs_qc)
openCyto::gt_gating(gt_tcell, gs)

# To prevent breakage down the road
gs_qc = gs
rm(gs)

# Extract intensity matrix from GatingSet object
## Grab marker names from GatingSet for labeling col names in intensity matrix
marker_chnl_names = 
  flowWorkspace::gh_pop_get_data(gs_qc) %>% 
  flowWorkspace::markernames() %>% 
  as.data.frame() %>% 
  tibble::rownames_to_column() %>% 
  dplyr::rename(chnl = rowname, 
         marker_full = ".") %>% 
  # clean up the names 
  dplyr::mutate(
    marker_full = janitor::make_clean_names(marker_full, replace = c("-" = "", "_" = "", " " = "")) %>% toupper()
  ) %>% 
  # Reorder the marker channel names to start with CD3, CD4, CD8 then the rest
  dplyr::arrange(match(marker_full, c("CD3", "CD4", "CD8"))) %>% 
  # Clean up
  dplyr::mutate(marker_full = ifelse(marker_full == "FOX_P3", "FOXP3", marker_full))

# For filtering out neg values below for any intensity cols
neg_intensity_thres = -2000

markers_to_gate = 
  marker_chnl_names$marker_full %>%
  .[!(. %in% c("CD3", "CD4", 'CD8', "LD", "CD1419"))]
  

## Grab the intensity matrix from GatingSet
## the gh_pop_get_indices grabs the 0/1 for whether gated as CD3
intensity_dat = 
  gs_qc %>% 
  flowWorkspace::gh_pop_get_indices(y = "cd3") %>% 
  cbind(gs_qc %>%  
          flowWorkspace::gh_pop_get_data() %>% 
          flowCore::exprs(),
        "cd3_pos" = .) %>% 
# add on the cd4 and cd8 0/1s
  cbind(., 
        "cd4_pos" = gh_pop_get_indices(gs_qc, y = "cd4+")) %>% 
  cbind(., 
        "cd8_pos" = gh_pop_get_indices(gs_qc, y = "cd8+")) %>% 
  tibble::as_tibble() %>%
  # Rename for plotting
  dplyr::rename(stats::setNames(marker_chnl_names$chnl, as.character(marker_chnl_names$marker_full))) %>%
  dplyr::mutate(
    cd4_pos_cd8_pos = case_when(
      cd3_pos == 1 & cd4_pos == 1 & cd8_pos == 1 ~ "cd4_pos_cd8_pos",
      cd3_pos == 1 & cd4_pos == 1 & cd8_pos == 0 ~ "cd4_pos_cd8_neg",
      cd3_pos == 1 & cd4_pos == 0 & cd8_pos == 1 ~ "cd4_neg_cd8_pos",
      cd3_pos == 1 & cd4_pos == 0 & cd8_pos == 0 ~ "cd4_neg_cd8_neg"
    )
  ) %>% 
  # additional step to remove large intensity values
  # 2023-05-26 Filter out any extremely negative values in cols of markers_to_gate
  dplyr::filter(!(if_any(all_of(markers_to_gate), ~.x < neg_intensity_thres)))

## Preview of intensity matrix
head(intensity_dat)

# # Check all cols of data
# intensity_dat %>% 
#   gtsummary::tbl_summary(statistic = gtsummary::all_continuous() ~ "{median} [{min}, {max}]")
```

```{r}
# Run density gating on 1 marker col
#Plot lag3
intensity_dat %>% 
  dplyr::filter(cd3_pos == 1) %>% 
  ggplot() + 
  geom_density(aes(LAG3)) + 
  facet_wrap(~cd4_pos_cd8_pos)

test_gate = 
  intensity_dat %>% 
# remove the cd3- 
  dplyr::filter(cd3_pos == 1) %>% 
  get_density_gates(. , 
                   "LAG3",
                   "cd4_pos_cd8_pos",
                   bin_n = 50,
                   peak_detect_ratio = 10,
                   pos_peak_threshold = 1600)

# Got results back
test_gate

# try get indicator col
test_i = 
  get_gated_dat(intensity_dat %>% 
                  dplyr::filter(cd3_pos == 1),
                subset_col = "cd4_pos_cd8_pos", 
                cutoffs = test_gate)

colnames(test_i)

dim(intensity_dat)
dim(test_i)
```

